using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Threading.Tasks;
using Dapper;
using ExistsForAll.DapperExtensions.Mapper;
using ExistsForAll.DapperExtensions.Sql;

namespace ExistsForAll.DapperExtensions.Postgresql
{
	public class PostgresqlDapperImplementor : DapperImplementor , IPostgresqlDapperImplementor
	{
		private new IPostgresqlGenerator SqlGenerator { get; }

		public PostgresqlDapperImplementor(IPostgresqlGenerator sqlGenerator,
			IClassMapperRepository classMappers,
			IDapperExtensionsConfiguration dapperExtensionsConfiguration) 
			: base(sqlGenerator, classMappers, dapperExtensionsConfiguration)
		{
			SqlGenerator = sqlGenerator;
		}

		public void Upsert<T>(IDbConnection connection, T entity, IDbTransaction transaction, int? commandTimeout) where T : class
		{
			var classMap = ClassMappers.GetMap<T>();

			var columns = classMap.GetNotIgnoredColumns();

			var autoGeneratedProperty = classMap.GetAutoGeneratedId();

			var guids = new IPropertyMap[0];

			if (Configuration.AutoPopulateKeyGuidValue)
			{
				guids = columns.Where(x => x.PropertyInfo.PropertyType == typeof(Guid)).ToArray();

				foreach (var guid in guids)
				{
					if ((Guid)guid.Getter(entity) != Guid.Empty)
						continue;

					var value = Configuration.GuidCreator.GetGuid();
					guid.Setter(entity, value);
				}
			}

			var sql = SqlGenerator.Upsert(classMap);

			var dynamicParameters = new DynamicParameters();

			foreach (var column in columns)
			{
				dynamicParameters.Add(column.Name, column.Getter(entity));
			}

			if (autoGeneratedProperty != null)
			{
				IEnumerable<long> result;
				if (SqlGenerator.SupportsMultipleStatements())
				{
					sql += Configuration.Dialect.BatchSeparator + SqlGenerator.IdentitySql(classMap);
					result = connection.Query<long>(sql, dynamicParameters, transaction, false, commandTimeout, CommandType.Text);
				}
				else
				{
					connection.Execute(sql, entity, transaction, commandTimeout, CommandType.Text);
					sql = SqlGenerator.IdentitySql(classMap);
					result = connection.Query<long>(sql, dynamicParameters, transaction, false, commandTimeout, CommandType.Text);
				}

				var hasResult = false;
				object identityInt = null;
				foreach (var identityValue in result)
				{
					if (hasResult)
					{
						continue;
					}

					identityInt = identityValue;
					hasResult = true;
				}
				if (!hasResult)
				{
					throw new InvalidOperationException("The source sequence is empty.");
				}

				autoGeneratedProperty.Setter(entity, Convert.ChangeType(identityInt, autoGeneratedProperty.PropertyInfo.PropertyType));
				return;
			}

			connection.Execute(sql, dynamicParameters, transaction, commandTimeout, CommandType.Text);
		}

		public async Task UpsertAsync<T>(IDbConnection connection, T entity, IDbTransaction transaction, int? commandTimeout) where T : class
		{
			var classMap = ClassMappers.GetMap<T>();

			var columns = classMap.GetNotIgnoredColumns();

			var autoGeneratedProperty = classMap.GetAutoGeneratedId();

			var guids = new IPropertyMap[0];

			if (Configuration.AutoPopulateKeyGuidValue)
			{
				guids = columns.Where(x => x.PropertyInfo.PropertyType == typeof(Guid)).ToArray();

				foreach (var guid in guids)
				{
					if ((Guid)guid.Getter(entity) != Guid.Empty)
						continue;

					var value = Configuration.GuidCreator.GetGuid();
					guid.Setter(entity, value);
				}
			}

			var sql = SqlGenerator.Upsert(classMap);

			var dynamicParameters = new DynamicParameters();

			foreach (var column in columns)
			{
				dynamicParameters.Add(column.Name, column.Getter(entity));
			}

			if (autoGeneratedProperty != null)
			{
				IEnumerable<long> result;
				if (SqlGenerator.SupportsMultipleStatements())
				{
					sql += Configuration.Dialect.BatchSeparator + SqlGenerator.IdentitySql(classMap);
					result = await connection.QueryAsync<long>(sql, dynamicParameters, transaction, commandTimeout, CommandType.Text);
				}
				else
				{
					await connection.ExecuteAsync(sql, entity, transaction, commandTimeout, CommandType.Text);
					sql = SqlGenerator.IdentitySql(classMap);
					result = await connection.QueryAsync<long>(sql, dynamicParameters, transaction, commandTimeout, CommandType.Text);
				}

				var hasResult = false;
				object identityInt = null;
				foreach (var identityValue in result)
				{
					if (hasResult)
					{
						continue;
					}

					identityInt = identityValue;
					hasResult = true;
				}
				if (!hasResult)
				{
					throw new InvalidOperationException("The source sequence is empty.");
				}

				autoGeneratedProperty.Setter(entity, Convert.ChangeType(identityInt, autoGeneratedProperty.PropertyInfo.PropertyType));
				return;
			}

			await connection.ExecuteAsync(sql, dynamicParameters, transaction, commandTimeout, CommandType.Text);
		}
	}
}
